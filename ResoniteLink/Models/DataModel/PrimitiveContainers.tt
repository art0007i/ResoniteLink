<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

// AUTOGENERATED!!! Do not modify! Your changes will be lost after .tt template regenerates.
// Modify the .tt template instead!

<#
HashSet<string> nonNullableTypes = new HashSet<string>()
{
    "string",
    "Uri",
};

List<string> standaloneTypes = new List<string>
{
    "byte",
    "ushort",
    "uint",
    "ulong",

    "sbyte",
    "short",
    "int",
    "long",

    "float",
    "double",

    "decimal",

    "bool",

    "char",
    "string",
    "Uri",

    "DateTime",
    "TimeSpan",

    "color",
    "colorX",
    "color32",
};

List<string> vectorTypes = new List<string>
{
    "float",
    "double",

    "byte",
    "ushort",
    "uint",
    "ulong",

    "sbyte",
    "short",
    "int",
    "long",

    "bool",
};

List<string> quaternionTypes = new List<string>
{
    "float",
    "double",
};

List<string> matrixTypes = new List<string>
{
    "float",
    "double",
};

List<string> primitiveTypes = new List<string>();

primitiveTypes.AddRange(standaloneTypes);

for(int dim = 2; dim <= 4; dim++)
    primitiveTypes.AddRange(vectorTypes.Select(v => v + dim));

primitiveTypes.AddRange(quaternionTypes.Select(v => v + "Q"));

for(int dim = 2; dim <= 4; dim++)
    primitiveTypes.AddRange(matrixTypes.Select(v => $"{v}{dim}x{dim}"));
#>

using System;
using System.Collections.Generic;
using System.Text;
using System.Text.Json.Serialization;

namespace ResoniteLink
{
    <#
    foreach(var type in primitiveTypes)
    {
        #>

        public class Field_<#=type#> : Field
        {
            [JsonPropertyName("value")]
            public <#=type#> Value { get; set; }

            [JsonIgnore]
            public override object BoxedValue { get => Value; set => Value = (<#=type#>)value; }

            [JsonIgnore]
            public override Type ValueType => typeof(<#=type#>);
        }

        public class Array_<#=type#> : SyncArray
        {
            [JsonPropertyName("values")]
            public List<<#=type#>> Values { get; set; }

            [JsonIgnore]
            public override Type ElementType => typeof(<#=type#>);
        }

        [JsonDerivedType(typeof(Field_<#=type#>), "<#=type#>")]
        [JsonDerivedType(typeof(Array_<#=type#>), "<#=type#>[]")]
        public partial class Member { }

        <#
        if(!nonNullableTypes.Contains(type))
        {
        #>
            public class Field_Nullable_<#=type#> : Field
            {
                [JsonPropertyName("value")]
                public <#=type#>? Value { get; set; }

                [JsonIgnore]
                public override object BoxedValue { get => Value; set => Value = value as <#=type#>?; }

                [JsonIgnore]
                public override Type ValueType => typeof(<#=type#>?);
            }

            [JsonDerivedType(typeof(Field_Nullable_<#=type#>), "<#=type#>?")]
            public partial class Member { }
            <#
        }
        #>

        <#
    }
    #>
}
